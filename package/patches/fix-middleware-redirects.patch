Use request.nextUrl instead of request.url for middleware redirects.

request.url contains the raw HTTP URL (e.g. http://localhost:3052/...)
which breaks when behind a reverse proxy. request.nextUrl respects
X-Forwarded-Host/Proto headers so redirects use the correct public domain.

--- a/src/middleware.ts
+++ b/src/middleware.ts
@@ -12,9 +12,10 @@

   // Handle GitHub OAuth callback redirect
   if (path.includes("/auth/callback/github") || path.includes("/auth/callback/google")) {
-    const redirectUrl = new URL(`/api${path}${request.nextUrl.search}`, request.url);
-    const response = NextResponse.redirect(redirectUrl);
-    response.headers.set("Cache-Control", "no-store, max-age=0");
+    const oauthUrl = request.nextUrl.clone();
+    oauthUrl.pathname = `/api${path}`;
+    const response = NextResponse.redirect(oauthUrl);
+    response.headers.set("Cache-Control", "no-store, max-age=0");
     return response;
   }

@@ -48,8 +49,10 @@
     }

     // Add cache control headers to make sure the redirect isn't cached
-    const response = NextResponse.redirect(new URL(`/${siteId}/main`, request.url));
-    response.headers.set("Cache-Control", "no-store, max-age=0");
+    const siteUrl = request.nextUrl.clone();
+    siteUrl.pathname = `/${siteId}/main`;
+    const response = NextResponse.redirect(siteUrl);
+    response.headers.set("Cache-Control", "no-store, max-age=0");
     return response;
   }

@@ -60,9 +63,10 @@
   if (privateKeyMatch) {
     const siteAndKey = privateKeyMatch[1]; // e.g., "123/abc123def456"

-    // Redirect to /main while preserving the private key in the path
-    const response = NextResponse.redirect(new URL(`/${siteAndKey}/main`, request.url));
-    response.headers.set("Cache-Control", "no-store, max-age=0");
+    const pkUrl = request.nextUrl.clone();
+    pkUrl.pathname = `/${siteAndKey}/main`;
+    const response = NextResponse.redirect(pkUrl);
+    response.headers.set("Cache-Control", "no-store, max-age=0");
     return response;
   }

